
### 使用的设计模式

1. **单例模式 (Singleton)**:
   虽然代码中没有明确展示，但 `Thread` 类中的静态成员函数 `GetThis()` 以及静态成员变量 `m_semaphore` 都可以被视为单例模式的实现。`GetThis()` 方法返回当前线程的 `Thread` 对象的指针，确保每个线程只有一个与之对应的 `Thread` 对象。`m_semaphore` 是一个用于线程同步的信号量，确保在某些操作中只有一个线程能够执行，也可以视作是一种单例资源的控制。

2. **策略模式 (Strategy)**:
   虽然代码中未显式使用策略模式，但 `Thread` 类中的 `Thread` 构造函数接受一个函数对象 `cb`，这样可以将不同的操作逻辑（策略）传递给 `Thread` 对象，从而在不同的线程中执行不同的操作。

3. **模板模式 (Template)**:
   代码中的 `ScopeLockImpl`、`ReadScopeLockImpl` 和 `WriteScopeLockImpl` 类以及对应的 `Mutex`、`NullMutex`、`RWMutex`、`NullRWMutex` 类，实现了一种模板模式，将不同的锁类型（作为模板参数）应用于不同的互斥体实现。

4. **装饰器模式 (Decorator)**:
   虽然代码中没有明确展示，但 `Thread` 类可以被视为使用装饰器模式，它对线程的操作进行了封装，可以添加额外的行为或属性，如 `m_name` 就是 `Thread` 对象的一个装饰属性。

5. **命令模式 (Command)**:
   虽然代码中没有明确展示，但 `Thread` 类中的 `run()` 函数可以被视为一个命令，传递给 `pthread_create` 函数以在新线程中执行。

需要注意的是，虽然上述设计模式在代码中有一定的体现，但代码中并没有直接使用设计模式的标准实现形式。设计模式的应用往往在于如何将其概念应用于具体的代码设计中，以达到代码清晰、可维护和可扩展的目标。